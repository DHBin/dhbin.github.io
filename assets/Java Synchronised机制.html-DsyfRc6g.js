import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as o,o as r}from"./app-CqnfWZLp.js";const n={};function l(c,e){return r(),a("div",null,e[0]||(e[0]=[o('<h1 id="java-synchronised机制" tabindex="-1"><a class="header-anchor" href="#java-synchronised机制"><span>Java Synchronised机制</span></a></h1><blockquote><p>Java中锁的控制可以参看这篇文章: <a href="http://blog.dreamtobe.cn/2015/03/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A2%E5%8D%A0/" target="_blank" rel="noopener noreferrer">Java多线程抢占</a>。</p></blockquote><h2 id="i-原末" tabindex="-1"><a class="header-anchor" href="#i-原末"><span>I. 原末</span></a></h2><h3 id="矛盾1" tabindex="-1"><a class="header-anchor" href="#矛盾1"><span>矛盾1</span></a></h3><p><strong>A</strong>: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。</p><p><strong>B</strong>: 锁大多数情况都是在很短的时间执行完成。</p><p><strong>解决方案</strong>: 引入轻量锁(通过自旋来完成锁竞争)。</p><h3 id="矛盾2" tabindex="-1"><a class="header-anchor" href="#矛盾2"><span>矛盾2</span></a></h3><p><strong>A</strong>: 轻量级锁中的自旋: 占用CPU时间，增加CPU的消耗(因此在多核处理器上优势更明显)。</p><p><strong>B</strong>: 如果某锁始终是被长期占用，导致自旋如果没有把握好，白白浪费CPU资源。</p><p><strong>解决方案</strong>: JDK5中引入默认自旋次数为10(用户可以通过<code>-XX:PreBlockSpin</code>进行修改)， JDK6中更是引入了自适应自旋（简单来说如果自旋成功概率高，就会允许等待更长的时间（如100次自旋），如果失败率很高，那很有可能就不做自旋，直接升级为重量级锁，实际场景中，HotSpot认为最佳时间应该是一个线程上下文切换的时间，而是否自旋以及自旋次数更是与对CPUs的负载、CPUs是否处于节电模式等息息相关的)。</p><h3 id="矛盾3" tabindex="-1"><a class="header-anchor" href="#矛盾3"><span>矛盾3</span></a></h3><p><strong>A</strong>: 无论是轻量级锁还是重量级锁: 在进入与退出时都要通过CAS修改对象头中的<code>Mark Word</code>来进行加锁与释放锁。</p><p><strong>B</strong>: 在一些情况下总是同一线程多次获得锁，此时第二次再重新做CAS修改对象头中的<code>Mark Word</code>这样的操作，有些多余。</p><p><strong>解决方案</strong>: JDK6引入偏向锁(首次需要通过CAS修改对象头中的<code>Mark Word</code>，之后该线程再进入只需要比较对象头中的<code>Mark Word</code>的Thread ID是否与当前的一致，如果一致说明已经取得锁，就不用再CAS了)。</p><h3 id="矛盾4" tabindex="-1"><a class="header-anchor" href="#矛盾4"><span>矛盾4</span></a></h3><p><strong>A</strong>: 项目中代码块中可能绝大情况下都是多线程访问。</p><p><strong>B</strong>: 每次都是先偏向锁然后过渡到轻量锁，而偏向锁能用到的又很少。</p><p><strong>解决方案</strong>: 可以使用<code>-XX:-UseBiasedLocking=false</code>禁用偏向锁。</p><h3 id="矛盾5" tabindex="-1"><a class="header-anchor" href="#矛盾5"><span>矛盾5</span></a></h3><p><strong>A</strong>: 代码中JDK原生或其他的工具方法中带有大量的加锁。</p><p><strong>B</strong>: 实际过程中，很有可能很多加锁是无效的(如局部变量作为锁，由于每次都是新对象新锁，所以没有意义)。</p><p><strong>解决方法</strong>: 引入锁削除(虚拟机即时编译器(JIT)运行时，依据逃逸分析的数据检测到不可能存在竞争的锁，就自动将该锁消除)。</p><h3 id="矛盾6" tabindex="-1"><a class="header-anchor" href="#矛盾6"><span>矛盾6</span></a></h3><p><strong>A</strong>: 为了让锁颗粒度更小，或者原生方法中带有锁，很有可能在一个频繁执行(如循环)中对同一对象加锁。</p><p><strong>B</strong>: 由于在频繁的执行中，反复的加锁和解锁，这种频繁的锁竞争带来很大的性能损耗。</p><p><strong>解决方法</strong>: 引入锁膨胀(会自动将锁的范围拓展到操作序列(如循环)外, 可以理解为将一些反复的锁合为一个锁放在它们外部)。</p><h2 id="ii-基本原理" tabindex="-1"><a class="header-anchor" href="#ii-基本原理"><span>II. 基本原理</span></a></h2><p>JVM会为每个对象分配一个<code>monitor</code>，而同时只能有一个线程可以获得该对象<code>monitor</code>的所有权。在线程进入时通过<code>monitorenter</code>尝试取得对象<code>monitor</code>所有权，退出时通过<code>monitorexit</code>释放对象<code>monitor</code>所有权。</p><blockquote><p><code>monitorenter</code>与<code>monitorexit</code>在编译后对称插入代码。</p></blockquote><ul><li><code>monitorenter</code>: 被插入到同步代码块之前。</li><li><code>monitorexit</code>: 被插到同步代码块之后或异常处。</li></ul><h3 id="_1-相关数据存在哪里" tabindex="-1"><a class="header-anchor" href="#_1-相关数据存在哪里"><span>1. 相关数据存在哪里?</span></a></h3><p>对象头。</p><h4 id="对象头结构" tabindex="-1"><a class="header-anchor" href="#对象头结构"><span>对象头结构</span></a></h4><blockquote><p>数组会多1字宽(32位: 4字节)来存储数组长度</p></blockquote><table><thead><tr><th style="text-align:left;">长度</th><th style="text-align:left;">内容</th><th style="text-align:left;">说明</th></tr></thead><tbody><tr><td style="text-align:left;">1字宽</td><td style="text-align:left;">Mark Word</td><td style="text-align:left;">存储对象的hashCode或锁信息等</td></tr><tr><td style="text-align:left;">1字宽</td><td style="text-align:left;">Class Metadata Address</td><td style="text-align:left;">存储对象类型数据的指针</td></tr><tr><td style="text-align:left;">1字宽</td><td style="text-align:left;">Array length</td><td style="text-align:left;">数组长度(如果是数组对象)</td></tr></tbody></table><p>而对象的锁，一般只和<code>Mark Word</code>有关。</p><h3 id="_2-各个锁的关系以及升级情况" tabindex="-1"><a class="header-anchor" href="#_2-各个锁的关系以及升级情况"><span>2. 各个锁的关系以及升级情况?</span></a></h3><blockquote><p>锁升级是单向的: 无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</p></blockquote><p><img src="http://dhbin.cn/usr/uploads/2019/07/3570686421.png" alt="img"></p><h2 id="iii-多线程下数据同步" tabindex="-1"><a class="header-anchor" href="#iii-多线程下数据同步"><span>III. 多线程下数据同步</span></a></h2><blockquote><p>这类锁/关键字主要是为了维护数据在高并发情况下的一致性/稳定性。</p></blockquote><h3 id="_1-数据库中的锁" tabindex="-1"><a class="header-anchor" href="#_1-数据库中的锁"><span>1. 数据库中的锁</span></a></h3><h4 id="共享锁-share-lock" tabindex="-1"><a class="header-anchor" href="#共享锁-share-lock"><span>共享锁(Share Lock)</span></a></h4><blockquote><p>又称为读锁</p></blockquote><p>多个线程可并发的获得某个数据的共享锁锁，并行读取数据。在数据存在共享锁期间，不能修改数据，不能加排他锁。</p><blockquote><p>如MySQL中，在查询语句最后加上<code>LOCK IN SHARE MODE</code>。</p></blockquote><h4 id="排他锁-exclusive-lock" tabindex="-1"><a class="header-anchor" href="#排他锁-exclusive-lock"><span>排他锁(eXclusive Lock)</span></a></h4><blockquote><p>又称为写锁</p></blockquote><p>同能只能有一个线程可以获得某个数据的排他锁。在线程获取排他锁后，该线程可对数据读写，但是其他线程不能对该数据添加任何锁。</p><h3 id="_2-volatile" tabindex="-1"><a class="header-anchor" href="#_2-volatile"><span>2. <code>volatile</code></span></a></h3><blockquote><p>如果一个共享变量被声明成<code>volatile</code>，java线程内存模型将会确保所有线程看到这个变量的值是一致的。</p></blockquote><ul><li><strong>基本策略</strong>: 写操作时，会有<code>Lock</code>前缀指定，处理器会立马将修改直接写回系统内存，并且其他处理器会将该值在其上的高速缓存标为无效。</li><li><strong>可能带来的性能消耗</strong>: 写操作实时写回内存，锁总线/锁内存。</li><li><strong>优势</strong>: 一些场景上相比<code>synchronized</code>，执行成本更低(不会引起线程上下文切换以及调度)，使用更方便。</li></ul><hr><ul><li><a href="http://www.cnblogs.com/mengheng/p/3491304.html" target="_blank" rel="noopener noreferrer">Java的多线程机制系列：(三）synchronized的同步原理</a></li><li><a href="http://www.cnblogs.com/lucifer1982/archive/2009/04/08/1431992.html" target="_blank" rel="noopener noreferrer">再说 lock-free 编程</a></li><li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile" target="_blank" rel="noopener noreferrer">聊聊并发（一）——深入分析Volatile的实现原理</a></li><li><a href="http://www.infoq.com/cn/articles/java-se-16-synchronized" target="_blank" rel="noopener noreferrer">聊聊并发（二）——Java SE1.6中的Synchronized</a></li><li><a href="http://blog.csdn.net/chen77716/article/details/6618779" target="_blank" rel="noopener noreferrer">深入JVM锁机制1-synchronized</a></li><li><a href="http://icyfenix.iteye.com/blog/1018932" target="_blank" rel="noopener noreferrer">虚拟机中的锁优化简介（适应性自旋/锁粗化/锁削除/轻量级锁/偏向锁）</a></li><li><a href="http://my.oschina.net/u/140462/blog/490897" target="_blank" rel="noopener noreferrer">Java偏向锁实现原理(Biased Locking)</a></li><li><a href="http://www.cnblogs.com/javaminer/p/3892288.html" target="_blank" rel="noopener noreferrer">JVM内部细节之二：偏向锁（Biased Locking）</a></li><li><a href="http://luojinping.com/2015/07/09/java%E9%94%81%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener noreferrer">java锁优化</a></li><li><a href="http://blog.sina.com.cn/s/blog_c038e9930102v2hs.html" target="_blank" rel="noopener noreferrer">Java锁Synchronized之偏向锁</a></li><li><a href="http://www.hollischuang.com/archives/923" target="_blank" rel="noopener noreferrer">MySQL中的共享锁与排他锁</a></li></ul>',55)]))}const h=t(n,[["render",l]]),p=JSON.parse('{"path":"/tech/java/Java%20Synchronised%E6%9C%BA%E5%88%B6.html","title":"Java Synchronised机制","lang":"zh-CN","frontmatter":{"date":"2019-07-07T23:15:00.000Z","category":["Java"],"tag":["原理","锁"],"description":"Java Synchronised机制 Java中锁的控制可以参看这篇文章: Java多线程抢占。 I. 原末 矛盾1 A: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。 B: 锁大多数情况都是在很短的时间执行完成。 解决方案: 引入轻量锁(通过自旋来完成锁竞争)。 矛盾2 A: 轻量级锁中的自旋: 占用CPU时间...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java Synchronised机制\\",\\"image\\":[\\"http://dhbin.cn/usr/uploads/2019/07/3570686421.png\\"],\\"datePublished\\":\\"2019-07-07T23:15:00.000Z\\",\\"dateModified\\":\\"2023-03-22T17:33:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"DHB\\",\\"url\\":\\"https://dhbin.cn\\"}]}"],["meta",{"property":"og:url","content":"https://dhbin.cn/tech/java/Java%20Synchronised%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"HB技术栈"}],["meta",{"property":"og:title","content":"Java Synchronised机制"}],["meta",{"property":"og:description","content":"Java Synchronised机制 Java中锁的控制可以参看这篇文章: Java多线程抢占。 I. 原末 矛盾1 A: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。 B: 锁大多数情况都是在很短的时间执行完成。 解决方案: 引入轻量锁(通过自旋来完成锁竞争)。 矛盾2 A: 轻量级锁中的自旋: 占用CPU时间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://dhbin.cn/usr/uploads/2019/07/3570686421.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-22T17:33:14.000Z"}],["meta",{"property":"article:tag","content":"锁"}],["meta",{"property":"article:tag","content":"原理"}],["meta",{"property":"article:published_time","content":"2019-07-07T23:15:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-22T17:33:14.000Z"}]]},"git":{"createdTime":1679384580000,"updatedTime":1679506394000,"contributors":[{"name":"donghaibin","username":"donghaibin","email":"xx158@qq.com","commits":1,"url":"https://github.com/donghaibin"},{"name":"dhb","username":"dhb","email":"xx158@qq.com","commits":1,"url":"https://github.com/dhb"}]},"readingTime":{"minutes":5.31,"words":1592},"excerpt":"\\n<blockquote>\\n<p>Java中锁的控制可以参看这篇文章: <a href=\\"http://blog.dreamtobe.cn/2015/03/25/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%A2%E5%8D%A0/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Java多线程抢占</a>。</p>\\n</blockquote>\\n<h2>I. 原末</h2>\\n<h3>矛盾1</h3>\\n<p><strong>A</strong>: 重量级锁中的阻塞(挂起线程/恢复线程): 需要转入内核态中完成，有很大的性能影响。</p>","autoDesc":true}');export{h as comp,p as data};
